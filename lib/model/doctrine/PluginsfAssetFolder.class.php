<?php

/**
 * PluginsfAssetFolder
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    sfDoctrineAssetsLibraryPlugin
 * @author     Massimiliano Arione
 * @author     Riccardo Bini
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
abstract class PluginsfAssetFolder extends BasesfAssetFolder
{
  public function __toString() {
    return $this->getRelativePath();
  }
  /**
   * @return string
   */
  public function getFullPath()
  {
    return sfAssetsLibraryTools::getMediaDir(true) . $this->getRelativePath();
  }
  
  /**
   * @return string
   */
  public function getParentPath()
  {
    if ($this->isRoot())
    {
      throw new sfException('Root node has no parent path');
    }
    $path = $this->getRelativePath();

    return trim(substr($path, 0, strrpos($path, '/')), '/');
  }
  
  /**
   * Gives the URL for the given folder
   *
   * @return string
   */
  public function getUrl()
  {
    return sfAssetsLibraryTools::getMediaDir() . $this->getRelativePath();
  }
    /**
     * @param  Doctrine_Connection $con
     * @return integer
     */
    public function save(Doctrine_Connection $con = null)
    {
      $this->updateRelitevePath();
      return parent::save($con);
    }

    protected function updateRelitevePath() {
      $modified = $this->getModified();
      if (!array_key_exists('relative_path', $modified))
      {
        $parent = $this->getParent();
        if ($parent !== false)
        {
          $this->setRelativePath($parent->getRelativePath().'/'.$this->getName());
        }
        else if ($this->isRoot()) 
        {
          $this->setRelativePath($this->getName());
        }
      }
      // physical existence
      if (!$this->existsPhysical())
      {
        if (!$this->create())
        {
          throw new sfAssetException('Impossible to create folder "%name%"', array('%name%' => $this->getRelativePath()));
        }
      }
    }
    
    /**
     * Folder physically exists
     *
     * @return bool
     */
    public function existsPhysical()
    {
      return is_dir($this->getRelativePath()) && is_writable($this->getRelativePath());
    }
    
    /**
     * Physically creates folder
     *
     * @return bool succes
     */
    public function create()
    {
      list ($base, $name) = sfAssetsLibraryTools::splitPath($this->getRelativePath());
  
      return sfAssetsLibraryTools::mkdir($name, $base);
    }
    
    public function isRoot() {
      return $this->getNode()->isRoot();
    }
    
  /**
   * Also delete all contents
   *
   * @param Connection $con
   * @param Boolean $force If true, do not throw an exception if the physical directories cannot be removed
   */
  public function delete(Doctrine_connection $con = null, $force = false)
  {
    $success = true;
    $descendants = $this->getNode()->getDescendants();
    if ($descendants !== false) {
      foreach ($descendants as $descendant)
      {
        $success = $descendant->delete($con, $force) && $success;
      }
    }

    foreach ($this->getAssets() as $asset)
    {
      $success = $asset->delete() && $success;
    }

    // Remove thumbnail subdir
    $success = rmdir(sfAssetsLibraryTools::getThumbnailDir($this->getFullPath())) && $success;
    // Remove dir itself
    $success = rmdir($this->getFullPath()) && $success;
    if ($success || $force)
    {
      parent::delete($con);
    }
    else
    {
      throw new sfAssetException('Impossible to delete folder "%name%"', array('%name%' => $this->getName()));
    }
    return $success;
  }
  
  public function getParent() {
      return $this->getNode()->getParent();
    }

  /**
   * Recursively move assets and folders from $old_path to $new_path
   *
   * @param string $old_path
   * @param string $new_path
   * @return bool success
   */
  static public function movePhysically($old_path, $new_path)
  {
    if (!is_dir($new_path) || !is_writable($new_path))
    {
      $old = umask(0);
      mkdir($new_path, 0770);
      umask($old);
    }

    $files = sfFinder::type('file')->maxdepth(0)->in($old_path);
    $success = true;
    foreach ($files as $file)
    {
      $success = rename($file, $new_path . '/' . basename($file)) && $success;
    }
    if ($success)
    {
      $folders = sfFinder::type('dir')->maxdepth(0)->in($old_path);
      foreach ($folders as $folder)
      {
        $new_name = substr($folder, strlen(realpath($old_path)));
        $success = self::movePhysically($folder, $new_path . '/' . $new_name) && $success;
      }
    }
    $success = @rmdir($old_path) && $success;

    return $success;
  }
    
  /**
   * Move under a new parent
   *
   * @param sfAssetFolder $new_parent
   */
  public function move(sfAssetFolder $new_parent)
  {
    // controls
    if ($this->isRoot())
    {
      throw new sfAssetException('The root folder cannot be moved');
    }
    else if ($new_parent->hasSubFolder($this->getName()))
    {
      throw new sfAssetException('The target folder "%folder%" already contains a folder named "%name%". The folder has not been moved.', array('%folder%' => $new_parent, '%name%' => $this->getName()));
    }
    else if ($new_parent->getNode()->isDescendantOf($this))
    {
      throw new sfAssetException('The target folder cannot be a subfolder of moved folder. The folder has not been moved.');
    }
    else if ($this->getParent() !== $new_parent->getId())
    {
//      $descendants = $this->getNode()->getDescendants();
      $old_path = $this->getFullPath();

      $this->getNode()->moveAsLastChildOf($new_parent);
      
      $descendants = $this->getNode()->getDescendants();
      if ($descendants !== false) {
        foreach ($descendants as $descendant)
        {
          // Update relative path
          $descendant->save();
        }
      }
      // Update relative path
      $this->save();
      // move its assets
      self::movePhysically($old_path, $this->getFullPath());
    }
    // else: nothing to do
  }
  
  /**
   * Change folder name
   *
   * @param string $name
   */
  public function rename($name)
  {
    if ($this->getParent()->hasSubFolder($name))
    {
      throw new sfAssetException('The parent folder already contains a folder named "%name%". The folder has not been renamed.', array('%name%' => $name));
    }
    else if ($name !== $this->getName())
    {
      if (sfAssetsLibraryTools::sanitizeName($name) != $name)
      {
        throw new sfAssetException('The target folder name "%name%" contains incorrect characters. The folder has not be renamed.', array('%name%' => $name));
      }
      $old_path = $this->getFullPath();
      $this->setName($name);
      $this->save();

      // move its assets
      self::movePhysically($old_path, $this->getFullPath());
      $descendants = $this->getNode()->getDescendants();
      if ($descendants !== false) {
        foreach ($this->getNode()->getDescendants() as $descendant)
        {
          $descendant->save();
        }
      }
    }
    // else: nothing to do
  }
  
  /**
   * Checks if a name already exists in the list of subfolders to a folder
   *
   * @param string $name A folder name
   * @return bool
   */
  public function hasSubFolder($name)
  {
    if ($this->getNode()->getChildren()) {
      foreach ($this->getNode()->getChildren() as $subfolder)
      {
        if ($subfolder->getName() == $name)
        {
          return true;
        }
      }
    }
    return false;
  }
  
  /**
   * get files of folder, sorted
   * @param  array  $dirs
   * @param  string $sortOrder
   * @return array
   */
  public function getSortedFiles($dirs, $sortOrder)
  {
    $query = sfAssetTable::getInstance()->createQuery();
    $query->where('folder_id = ?', $this->getId());

    switch ($sortOrder)
    {
      case 'date':
        $dirs = sfAssetFolderTable::getInstance()->sortByDate($dirs);
        $query->orderBy('created_at DESC');
//        $c->addDescendingOrderByColumn(sfAssetPeer::CREATED_AT);
        break;
      default:
        $dirs = sfAssetFolderTable::getInstance()->sortByName($dirs);
        $query->orderBy('filename ASC');
//        $c->addAscendingOrderByColumn(sfAssetPeer::FILENAME);
    }

    return $query->execute();
  }
  
  /**
   * @return array
   */
  public function getAssetsWithFilenames()
  {
    return sfAssetTable::getInstance()->getAssetsWithFilenames($this->getId());
  }
  
  /**
   * @return array
   */
  public function getSubfoldersWithFolderNames()
  {
    $foldernames = array();
    foreach ($this->getChildren() as $folder)
    {
      $foldernames[$folder->getName()] = $folder;
    }

    return $foldernames;
  }
  
  /**
   * Synchronize with a physical folder
   *
   * @param string  $base_folder base folder path
   * @param boolean $verbose If true, every file or database operation will issue an alert in STDOUT
   * @param boolean $removeOrphanAssets If true, database assets with no associated file are removed
   * @param boolean $removeOrphanFolders If true, database folders with no associated directory are removed
   */
  public function synchronizeWith($baseFolder, $verbose = true, $removeOrphanAssets = false, $removeOrphanFolders = false)
  {
    if (!is_dir($baseFolder))
    {
      throw new sfAssetException(sprintf('%s is not a directory', $baseFolder));
    }

    $files = sfFinder::type('file')->maxdepth(0)->ignore_version_control()->in($baseFolder);
    $assets = $this->getAssetsWithFilenames();
    foreach ($files as $file)
    {
      if (!array_key_exists(basename($file), $assets))
      {
        // File exists, asset does not exist: create asset
        $sfAsset = new sfAsset();
        $sfAsset->setFolderId($this->getId());
        $sfAsset->create($file, false);
        $sfAsset->save();
        if ($verbose)
        {
          sfAssetsLibraryTools::log(sprintf("Importing file %s", $file), 'green');
        }
      }
      else
      {
        // File exists, asset exists: do nothing
        unset($assets[basename($file)]);
      }
    }

    foreach ($assets as $name => $asset)
    {
      if ($removeOrphanAssets)
      {
        // File does not exist, asset exists: delete asset
        $asset->delete();
        if ($verbose)
        {
          sfAssetsLibraryTools::log(sprintf("Deleting asset %s", $asset->getUrl()), 'yellow');
        }
      }
      else
      {
        if ($verbose)
        {
          sfAssetsLibraryTools::log(sprintf("Warning: No file for asset %s", $asset->getUrl()), 'red');
        }
      }
    }

    $dirs = sfFinder::type('dir')->maxdepth(0)->discard(sfConfig::get('app_sfAssetsLibrary_thumbnail_dir', 'thumbnail'))->ignore_version_control()->in($baseFolder);
    $folders = $this->getSubfoldersWithFolderNames();
    foreach ($dirs as $dir)
    {
      list(,$name) = sfAssetsLibraryTools::splitPath($dir);
      if (!array_key_exists($name, $folders))
      {
        // dir exists in filesystem, not in database: create folder in database
        $sfAssetFolder = new sfAssetFolder();
        $sfAssetFolder->insertAsLastChildOf($this->reload());
        $sfAssetFolder->setName($name);
        $sfAssetFolder->save();
        if ($verbose)
        {
          sfAssetsLibraryTools::log(sprintf("Importing directory %s", $dir), 'green');
        }
      }
      else
      {
        // dir exists in filesystem and database: look inside
        $sfAssetFolder = $folders[$name];
        unset($folders[$name]);
      }
      $sfAssetFolder->synchronizeWith($dir, $verbose, $removeOrphanAssets, $removeOrphanFolders);
    }

    foreach ($folders as $name => $folder)
    {
      if ($removeOrphanFolders)
      {
        $folder->delete(null, true);
        if ($verbose)
        {
          sfAssetsLibraryTools::log(sprintf("Deleting folder %s", $folder->getRelativePath()), 'yellow');
        }
      }
      else
      {
        if ($verbose)
        {
          sfAssetsLibraryTools::log(sprintf("Warning: No directory for folder %s", $folder->getRelativePath()), 'red');
        }
      }
    }

  }
  
}